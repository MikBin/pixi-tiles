{"code":"import { GlowFilter } from \"pixi-filters\";\r\nvar mainGraphicType;\r\n(function (mainGraphicType) {\r\n    mainGraphicType[mainGraphicType[\"Graphics\"] = 0] = \"Graphics\";\r\n    mainGraphicType[mainGraphicType[\"Sprite\"] = 1] = \"Sprite\";\r\n})(mainGraphicType || (mainGraphicType = {}));\r\n;\r\nconst startGlowFilterValues = [0, 0, 0, 0xFFFFFF, 0.1];\r\nclass PixiTile {\r\n    constructor(globalConfig, APP, _TEXTURES_LIST, _value = 0) {\r\n        this.globalConfig = globalConfig;\r\n        this.APP = APP;\r\n        this._TEXTURES_LIST = _TEXTURES_LIST;\r\n        this._value = _value;\r\n        this._TINT_ANIMATION_DATA = { currentStep: 0, totalSteps: 0, tintStep: 0 };\r\n        this.graphicsType = mainGraphicType.Graphics;\r\n        this._GRAPHICS_OBJECT = PixiTile.createTileAsGraphics(globalConfig, _value);\r\n        this._SPRITE_OBJECT = new PIXI.Sprite(_TEXTURES_LIST[_value]);\r\n        this._SLIDE_DATA = { currentStep: 0, slideAmountX: 0, slideAmountY: 0, totalSteps: 0, objectToMove: this._GRAPHICS_OBJECT };\r\n        this.doubleValueFilter = new GlowFilter();\r\n        this._SPRITE_OBJECT.filters = [this.doubleValueFilter];\r\n    }\r\n    setSpriteMode() {\r\n        this.graphicsType = mainGraphicType.Sprite;\r\n        this._SLIDE_DATA.objectToMove = this._SPRITE_OBJECT;\r\n    }\r\n    ;\r\n    createGraphics() {\r\n        this._GRAPHICS_OBJECT = PixiTile.createTileAsGraphics(this.globalConfig, this._value);\r\n        return this;\r\n    }\r\n    ;\r\n    moveTo(x, y) {\r\n        let objectToMove = this._SLIDE_DATA.objectToMove = this.graphicsType === mainGraphicType.Graphics ? this._GRAPHICS_OBJECT : this._SPRITE_OBJECT;\r\n        objectToMove.x = x;\r\n        objectToMove.y = y;\r\n    }\r\n    ;\r\n    prepareFilterAnimation() { }\r\n    ;\r\n    resetFilterAnimation() { }\r\n    ;\r\n    slideOfPrepareFn(x, y, steps) {\r\n        this._SLIDE_DATA.currentStep = 0;\r\n        this._SLIDE_DATA.totalSteps = steps;\r\n        this._SLIDE_DATA.slideAmountX = x / this.globalConfig.tileFullSize;\r\n        this._SLIDE_DATA.slideAmountY = y / this.globalConfig.tileFullSize;\r\n        this._SLIDE_DATA.objectToMove = this.graphicsType === mainGraphicType.Graphics ? this._GRAPHICS_OBJECT : this._SPRITE_OBJECT;\r\n    }\r\n    ;\r\n    slideOf_percent_PrepareFn(x, y, steps) {\r\n    }\r\n    ;\r\n    slideToPrepareFn(x, y, steps) {\r\n    }\r\n    ;\r\n    slideStep() {\r\n        let _SLIDE_DATA = this._SLIDE_DATA;\r\n        if (_SLIDE_DATA.currentStep === _SLIDE_DATA.totalSteps) {\r\n            return 0;\r\n        }\r\n        _SLIDE_DATA.currentStep++;\r\n        let objectToMove = _SLIDE_DATA.objectToMove;\r\n        objectToMove.x += _SLIDE_DATA.slideAmountX;\r\n        objectToMove.y += _SLIDE_DATA.slideAmountY;\r\n        return _SLIDE_DATA.currentStep;\r\n    }\r\n    ;\r\n    resetSlideData() {\r\n        this._SLIDE_DATA.currentStep = 0;\r\n        this._SLIDE_DATA.totalSteps = 0;\r\n        this._SLIDE_DATA.slideAmountX = 0;\r\n        this._SLIDE_DATA.slideAmountY = 0;\r\n        return this;\r\n    }\r\n    ;\r\n    set faceValue(v) {\r\n        this._value = v;\r\n        if (this.graphicsType === mainGraphicType.Sprite) {\r\n            this._SPRITE_OBJECT.texture = this._TEXTURES_LIST[this._value];\r\n        }\r\n        else {\r\n            let numberElement = this._GRAPHICS_OBJECT.children[0];\r\n            if (v !== 0) {\r\n                numberElement.text = `${v}`;\r\n                numberElement.style.fill = v > 0 ? this.globalConfig.tileNumberColors[v] : this.globalConfig.negativeNumberColor;\r\n            }\r\n            else {\r\n                numberElement.text = '';\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    get faceValue() {\r\n        return this._value;\r\n    }\r\n    ;\r\n    set X(x) {\r\n        this.absX = x;\r\n    }\r\n    ;\r\n    set Y(y) {\r\n        this.absY = y;\r\n    }\r\n    ;\r\n    getGraphics() {\r\n        return this._GRAPHICS_OBJECT;\r\n    }\r\n    ;\r\n    getSprite() {\r\n        return this._SPRITE_OBJECT;\r\n    }\r\n    ;\r\n    getObjectToUse() {\r\n        return this.graphicsType === mainGraphicType.Graphics ? this._GRAPHICS_OBJECT : this._SPRITE_OBJECT;\r\n    }\r\n    ;\r\n    setGraphicsFaceValue() { }\r\n    ;\r\n    setSpriteFaceValue() { }\r\n    ;\r\n    prepareAnimateTint(tint, steps) { }\r\n    ;\r\n    animateTintStep() {\r\n        return 0;\r\n    }\r\n    ;\r\n    static createTileAsGraphics(_CONF, val) {\r\n        let aTile = new PIXI.Graphics();\r\n        aTile.beginFill(_CONF.tileBackColor, _CONF.defaultAlpha);\r\n        aTile.drawRoundedRect(0, 0, _CONF.tileSize, _CONF.tileSize, _CONF.roundBorderFactor);\r\n        aTile.endFill();\r\n        aTile.interactiveChildren = false;\r\n        if (val !== 0 && val !== null) {\r\n            let cellNumber = '';\r\n            cellNumber = val;\r\n            let textColor = cellNumber > 0 ? _CONF.tileNumberColors[cellNumber] : _CONF.negativeNumberColor;\r\n            let number = new PIXI.Text(`${cellNumber}`, {\r\n                fontWeight: 'bold',\r\n                fontSize: _CONF.fontSize,\r\n                fontFamily: 'Roboto',\r\n                fill: textColor,\r\n                align: 'center'\r\n            });\r\n            number.x = aTile.width / 2;\r\n            number.y = aTile.height / 2;\r\n            number.anchor.set(0.5, 0.5);\r\n            aTile.addChild(number);\r\n        }\r\n        return aTile;\r\n    }\r\n    ;\r\n}\r\nclass TorusPixiTile extends PixiTile {\r\n}\r\nexport { PixiTile };\r\n//# sourceMappingURL=PixiTile.js.map","map":"{\"version\":3,\"file\":\"PixiTile.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/PixiTile.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import { slideData } from \\\"./interfaces\\\";\\nimport { tintAnimationData } from \\\"./interfaces\\\";\\nimport { graphicsConfiguration } from \\\"./interfaces\\\";\\nimport { Graphics } from \\\"pixi.js\\\";\\n//import * as __filters from \\\"pixi-filters\\\";\\nimport { GlowFilter } from \\\"pixi-filters\\\";\\n\\n// @ts-ignore\\n//const __filters = window.__filters;\\n\\nenum mainGraphicType { Graphics, Sprite };\\nconst startGlowFilterValues: number[] = [0, 0, 0, 0xFFFFFF, 0.1];\\n\\nclass PixiTile {\\n    private _GRAPHICS_OBJECT: PIXI.Graphics;\\n    private _SPRITE_OBJECT: PIXI.Sprite;\\n    private _SLIDE_DATA: slideData;\\n    private _TINT_ANIMATION_DATA: tintAnimationData;\\n    private graphicsType: mainGraphicType;\\n    private doubleValueFilter: GlowFilter;\\n    /**integer coordinates relative to rowsXcols grid size  --> independent of canvas size */\\n    private absX: number;\\n    private absY: number;\\n    constructor(private globalConfig: any, private APP: PIXI.Application, private _TEXTURES_LIST: PIXI.Texture[], private _value: number | string = 0) {\\n\\n        this._TINT_ANIMATION_DATA = { currentStep: 0, totalSteps: 0, tintStep: 0 };\\n        this.graphicsType = mainGraphicType.Graphics;\\n        this._GRAPHICS_OBJECT = PixiTile.createTileAsGraphics(globalConfig, _value);\\n        this._SPRITE_OBJECT = new PIXI.Sprite(_TEXTURES_LIST[_value]);\\n        this._SLIDE_DATA = { currentStep: 0, slideAmountX: 0, slideAmountY: 0, totalSteps: 0, objectToMove: this._GRAPHICS_OBJECT };\\n        this.doubleValueFilter = new GlowFilter();\\n        this._SPRITE_OBJECT.filters = [this.doubleValueFilter];\\n\\n    }\\n    setSpriteMode(): void {\\n        this.graphicsType = mainGraphicType.Sprite;\\n        this._SLIDE_DATA.objectToMove = this._SPRITE_OBJECT;\\n    };\\n    createGraphics(): PixiTile {\\n        this._GRAPHICS_OBJECT = PixiTile.createTileAsGraphics(this.globalConfig, this._value);\\n        return this;\\n    };\\n    moveTo(x: number, y: number): void {\\n        let objectToMove = this._SLIDE_DATA.objectToMove = this.graphicsType === mainGraphicType.Graphics ? this._GRAPHICS_OBJECT : this._SPRITE_OBJECT;\\n        objectToMove.x = x;\\n        objectToMove.y = y;\\n    };\\n    prepareFilterAnimation() { };\\n    resetFilterAnimation() { };\\n    slideOfPrepareFn(x: number, y: number, steps: number): void {\\n        this._SLIDE_DATA.currentStep = 0;\\n        this._SLIDE_DATA.totalSteps = steps;\\n        this._SLIDE_DATA.slideAmountX = x / this.globalConfig.tileFullSize;\\n        this._SLIDE_DATA.slideAmountY = y / this.globalConfig.tileFullSize;\\n        this._SLIDE_DATA.objectToMove = this.graphicsType === mainGraphicType.Graphics ? this._GRAPHICS_OBJECT : this._SPRITE_OBJECT;\\n        /**calculate steps amount for X and Y */\\n    };\\n    slideOf_percent_PrepareFn(x: number, y: number, steps: number): void {\\n        /**call slideOfPrepare */\\n    };\\n    slideToPrepareFn(x: number, y: number, steps: number): void {\\n        /**call slideOfPrepare */\\n    };\\n    slideStep(): number {\\n        let _SLIDE_DATA = this._SLIDE_DATA;\\n        if (_SLIDE_DATA.currentStep === _SLIDE_DATA.totalSteps) {\\n            //resetHere?\\n            return 0;\\n        }\\n        _SLIDE_DATA.currentStep++;\\n        let objectToMove = _SLIDE_DATA.objectToMove;\\n        objectToMove.x += _SLIDE_DATA.slideAmountX;\\n        objectToMove.y += _SLIDE_DATA.slideAmountY;\\n        return _SLIDE_DATA.currentStep;\\n    };\\n    resetSlideData(): PixiTile {\\n        this._SLIDE_DATA.currentStep = 0;\\n        this._SLIDE_DATA.totalSteps = 0;\\n        this._SLIDE_DATA.slideAmountX = 0;\\n        this._SLIDE_DATA.slideAmountY = 0;\\n        return this;\\n    };\\n    set faceValue(v: number | string) {\\n        /**depending on graphicsType change one of the two */\\n        this._value = v;\\n        if (this.graphicsType === mainGraphicType.Sprite) {\\n            this._SPRITE_OBJECT.texture = this._TEXTURES_LIST[this._value];\\n        } else {\\n\\n            let numberElement = this._GRAPHICS_OBJECT.children[0] as PIXI.Text;\\n\\n            if (v !== 0) {\\n                numberElement.text = `${v}`;\\n                numberElement.style.fill = v > 0 ? this.globalConfig.tileNumberColors[v] : this.globalConfig.negativeNumberColor;\\n            } else {\\n                numberElement.text = '';\\n            }\\n\\n        }\\n    };\\n    get faceValue(): number | string {\\n        return this._value;\\n    };\\n    set X(x: number) {\\n        this.absX = x;\\n    };\\n    set Y(y: number) {\\n        this.absY = y;\\n    };\\n    getGraphics(): PIXI.Graphics {\\n        return this._GRAPHICS_OBJECT;\\n    };\\n    getSprite(): PIXI.Sprite {\\n        return this._SPRITE_OBJECT;\\n    };\\n    getObjectToUse(): PIXI.Sprite | PIXI.Graphics {\\n        return this.graphicsType === mainGraphicType.Graphics ? this._GRAPHICS_OBJECT : this._SPRITE_OBJECT;\\n    };\\n    setGraphicsFaceValue() { };\\n    setSpriteFaceValue() { };\\n    prepareAnimateTint(tint: number, steps: number): void { };\\n    animateTintStep(): number {\\n        return 0;\\n    };\\n    static createTileAsGraphics(_CONF: graphicsConfiguration, val: number | string | null) {\\n\\n        let aTile: PIXI.Graphics = new PIXI.Graphics();\\n\\n        aTile.beginFill(_CONF.tileBackColor, _CONF.defaultAlpha);\\n\\n        aTile.drawRoundedRect(0, 0, _CONF.tileSize, _CONF.tileSize, _CONF.roundBorderFactor);\\n        aTile.endFill();\\n        aTile.interactiveChildren = false;\\n\\n        if (val !== 0 && val !== null) {\\n            let cellNumber: number | string | null = '';\\n            cellNumber = val;\\n            let textColor: number = cellNumber > 0 ? _CONF.tileNumberColors[cellNumber] : _CONF.negativeNumberColor;\\n\\n\\n            let number: PIXI.Text = new PIXI.Text(`${cellNumber}`, {\\n                fontWeight: 'bold',\\n                fontSize: _CONF.fontSize,\\n                fontFamily: 'Roboto',\\n                fill: textColor,\\n                align: 'center'\\n            });\\n\\n            number.x = aTile.width / 2;\\n            number.y = aTile.height / 2;\\n            number.anchor.set(0.5, 0.5);\\n            aTile.addChild(number);\\n        }\\n\\n        return aTile;\\n    };\\n}\\n\\n\\nclass TorusPixiTile extends PixiTile {\\n\\n}\\nexport { PixiTile };\"]}"}
